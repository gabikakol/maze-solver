# Implementation

## Structure

Code is divided into files: ```index.py```, ```tremaux.py```, ```wall_follower.py```, ```generate.py```, ```visualize.py```. <br/>
<br/>


1. **index** <br/>
Uses PyGame menu library to display the menu for the user. It asks for inputs: width and height of the maze, and selection of the algorithm to solve the maze: Tremaux or Wall Follower. Wdith and height must be integers in range 3-30. Using the input data, it calls either class ```Tremaux()``` from ```tremaux.py``` file or class ```WallFollower()``` from ```wall_follower.py``` file and passes the width and height arguments. <br/> 

<p align="center">
<br/> <img src="UI_screenshots/index_menu.png" width="700">
</p>

2. **tremaux** <br/>
Finds the solution path for the maze generated by ```Generate()``` class using Tremaux algorithm. Checks walkable cells (marked ```0```) one by one. First tries to go right, if not possible - go straight, and if not possible - go left. Program starts with the entrance to the maze as a current cell. With every visit, +1 is added to the current cell of the path. If it's a dead end, it goes back following the path it came from and it marks the cells with ```x``` as incorrect path until it finds the first possible intersection with unvisited cells. The recursion stops when exit is found. Solution path is marked with integers starting from 1 (0 - unvisited cell, ie. not solution path). 

3. **wall_follower** <br/>
Finds the solution path for the maze generated by ```Generate()``` class using Wall Follower algorithm. Checks walkable cells (marked ```0```) following the route of the left-hand size. The program starts with the maze entrance marked as current cell. It is in the first row of the maze and "standing" on such cell in the walkable direction we face south, hence the left wall is to the east.
    - facing SOUTH, left wall is to the EAST  
    - facing EAST, left wall is to the NORTH
    - facing NORTH, left wall is to the WEST
    - facing WEST, left wall is to the SOUTH <br/>

    The algorithm first checks if there is a wall to the left of the current cell. If not, the solution path goes one step (cell) to its left. Else, the program checks if there is wall in front of the current cell. If there's no wall, one step forward is taken. If there is a wall, the program checks if there is a wall to the right. If there is no wall, one step to the right is taken. By such recursion, the exit is eventually found. However, It is not the shortest solution path, Since it always follows the left wall, it means that the path takes all the (unnecessary) turns - that is shortened when using Tremaux algorithm. 

4. **generate** <br/>
??

5. **visualize** <br/>
??


1. **generate_maze** <br/>
First an empty grid of a maze is generated (dimensions specified by user input. Next, coordinates of a starting point are choosen randomly (it cannot be on the border, ie. not the first or last column on row). That point is where generating the path starts and it becomes the current cell - function ```self.current_cell()```. That cell is marked as a walkable path and walls are drawn around it. From the existing walls one is chosen randomly and it becomes a new current cell. It is marked as a path and walls are drawn aroudn it (only empty cells become walls, paths remain walkable). Current cell is chosen again and again, and the maze is created by this recursion. Remaining empty (invisited, marked ```'x'``` cells become wallls, and function ```self.entrance_exit()``` randomly chooses ```self.entrance``` and ```self.exit``` - points where solution path of the maze should start and finish (entrance is always in the first row and exit in the last row). <br/>

2. **find_solution** <br/>
Function ```self.current_cell()``` uses entrance point to initiate the recursion. Program checks for possible junction and follows the walkable path. The next ```'.'``` cell, ie. path, becomes the current cell and its junction is searched. If there is junction, the recursion continues. If there is no junction (ie. there are no unvisited cells that are not walls), function ```self.return_to_junction()``` is called. Program goes back to the previous current cell (one step back on the path) and checks for it's other junctions (with unvisited walkable cells). The recursion occurs until junction is found and program continues as before. Every time the function ```self.current_cell()``` is called, it checks if the cell is the exit. If it is, recursion is stopped as solution path has been found. <br/>
3. **main** <br/>
Program initiates pygame and uses user input (ie. height and width of the maze) to set dimenstions of the pygame window. In the class ```Draw()``` there are functions which draw empty maze and solution path (in red) in the pygame window. <br/>

## Performance

![](graph_analysis/prims_graph.png)
![](graph_analysis/tremaux_graph.png)
![](graph_analysis/wall_follower_graph.png)

